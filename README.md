[![Netlify Status](https://api.netlify.com/api/v1/badges/b1b84831-789e-4629-a9e3-55a36e136653/deploy-status)](https://app.netlify.com/sites/sharp-babbage-154f0a/deploys)

# Vue Component Library Starter

> Создание собственной библиотеки компонентов [Vue 3](https://v3.vuejs.org/) с использованиеим TypeScript, [Vite](https://vitejs.dev) и [VitePress](https://vitepress.vuejs.org/).

Рано или поздно, вы поймете, что создание библиотеки компонентов лучше, чем иметь сразу все компоненты в вашем проекте. Библиотека компонентов позволит вам убрать логику приложения из ваших компонентов, упростить тестирование, а также позволит переиспользовать ваши компоненты в других приложениях.

Когда компоненты собраны в библиотеку, документирование их становится критически важным. Поэтому данный стартовый проект включает в себя приложение для документирования на базе VitePress. Оно не только документирует использование компонентов, но позволяет создавать испытательный стенд на время разработки компонетов. Пример сгенерированной документации можно увидеть [здесь](https://sharp-babbage-154f0a.netlify.app/).

## Установка

При первом запуске `docs:dev` вы можете получить ошибку в браузере вроде `vitepress data not properly injected in app`. Просто перезапустите сервис и перезагрузите страницу в браузере.

````
# установка зависимостей

npm install

# запуск документирования с горячей перезагрузкой, хорошо для тестирования компонентов

npm run docs:dev

# сборка библиотеки, собирается в папку ./dist

npm run build

# сборка документации, собирается в папку docs/.vitepress/dist

npm run docs:build

# preview the doc app locally from docs/.vitepress/dist

npm run docs:serve
````

## Разработка и локальное тестирование

Лучший способ для разработки и тестирования ваших компонентов — это создать демо в папке `docs/components/demo`, как это показано в примерах компонентов.

Если вы хотите тестировать вашу библиотеку непосредственно в вашем приложении, то:

* В корневой папке библиотеки выполните команду `npm link`. Это создат символическую ссылку на библиотеку.
* В корневой папке вашего приложения выполните команду `npm link my-lib`. Это создаст символическую ссылку в папке `node_modules` вашего приложения.
* Теперь вы можете импортировать вашу `my-lib` внутри своего приложения.

В данном случае вам нет необходимости устанавливать зависимость в package.json.

После внесения изменений в библиотеке вам будет необходимо ее пересобрать. А ваше приложение на Vue автоматически перезагрузится, когда библиотека будет пересобрана.

## Как это работает

### Компоненты

Библитека компонентов  —это [плагин Vue](https://v3.vuejs.org/guide/plugins.html). Функция `install` в [index.ts](src/index.ts) **глобально** регистрирует все компоненты из папки [components](src/components) в приложении Vue.

Компоненты также экспортируются с помощью [index.ts](src/index.ts) так, чтобы вы могли импортировать их в свое приложение по отдельности, вместо использования библиотеки в качестве подключаемого модуля. Это может уменьшить размер бандла, если ваше приложение использует лишь отдельные компоненты из библиотеки.

Так как для Vue 3 существует довольно большое количество компонентов пользовательского интерфейса, вы можете захотеть использовать один из них в качестве базы для разработки своих компонентов. Например, **Component B** демонстрирует пример использования библиотеки [PrimeVue](https://www.primefaces.org/primevue/) в качестве базовой. При этом это означает, что ваше клиентское приложение тоже должно использовать эту библиотеку.

Например, приложение `doc app` само является клиентским приложением, которое импортирует PrimeVue (см. [docs/.vitepress/theme/index.js](docs/.vitepress/theme/index.js)). Код в конфигурации [docs/.vitepress/config.js](docs/.vitepress/config.js), приведенный ниже, разрешает не дублировать эти модули (Vue и PrimeVue), что позволяет избежать конфликтов при процессе выполнения.

```js
module.exports = {
  vite: {
    resolve: {
      dedupe: ['vue', /primevue\/.+/],
    },
  },
}
```

> В [vite.config.ts](vite.config.ts) в параметре `build.lib.formats` отсутствует формат 'umd'. Это связано с тем, что компоненты PrimeVue, используемые данной библиотекой, являются внешними и требуют соответствующих параметров в `rollupOptions.output.globals`. Чтобы не добавлять эти параметры и упростить конфигурацию, 'ump' удален из нее.

### Утилиты и константы

Библиотека включает примеры утилит и констант. Они также будут экспортированы в [index.ts](src/index.ts), а клиентское приложение может их использовать, например:

```js
<script lang="ts">
import { MyConstants, MyUtil } from 'my-lib'

export default {
  data () {
    return {
      magicNum: MyConstants.MAGIC_NUM
    }
  },
  methods: {
    add (a:number, b:number) {
      return MyUtil.add(a, b)
    }
  }
}
</script>
```

### Стили

Отдельный компонент может иметь собственное стилевое оформление, описанное в файле `.vue`. Оно будет обработано, объединено и минифицировано в `dist/style.css`, как это описано в списке `exports` файла [package.json](package.json).

Если у вас есть стили, которые используются в нескольких или всех компонентах библиотеки, вы можете добавить их в [src/assets/main.scss](src/assets/main.scss). Этот файл импортируется в [index.ts](src/index.ts) и после обработки будет включен в `dist/style.css`. Чтобы избежать конфликтов с другими глобальными стилями, необходимо продумать систему именования стилей или оборачивать их в namespace-классы.

Если у вас есть собственный набор SVG-изображений, вы можете создать WOFF-шрифт (`.woff`), используя инструменты такие, как [Icomoon](https://icomoon.io/) или [Fontello](https://fontello.com/). Данный стартер включает пример подобного файла [src/assets/fonts/myfont.woff](src/assets/fonts/myfont.woff) и ссылается на него в файле [src/assets/main.scss](src/assets/main.scss). Иконка из этого шрифта используется в **Component A**. Vite может включить этот файл в билд, подробнее см. [https://vitejs.dev/guide/assets.html](https://vitejs.dev/guide/assets.html).

Клиентское приложение должно импортировать `style.css` как единый файл:

```js
import 'my-lib/dist/style.css'
```

### Сторонние зависимости

Сторонние библиотеки, которые использует ваша библиотека, могут сильно увеличить размер сборки вашей библиотеки, если вы просто добавить их в `dependencies` файла [package.json](package.json).

Следующие стратегии помогут сократить размер вашей библиотеки:

#### Экстернализация

Если вы полагает, что клиентское приложение может так же нуждаться в такой же зависимости, вы можете сделать эту зависимость внешней. Например, чтобы исключить PrimeVue из вашей библиотеки, в файле [vite.config.ts](vite.config.ts) вам необходимо указать:

```js
module.exports = defineConfig({
    rollupOptions: {
      external: ['vue', /primevue\/.+/]
    }
  }
})
```

Внешняя зависимость может быть объявлена как одноранговая зависимость (Peer dependencies) в вашей библиотеке. Почитать можно [здесь](https://habr.com/ru/company/otus/blog/545008/) или [здесь](https://blog.bitsrc.io/understanding-peer-dependencies-in-javascript-dbdb4ab5a7be).

#### Cherry picking

> Cherry picking - выбор лучших или наиболее желанных предметы из списка или группы, особенно для получения некоторого преимущества или представления чего-либо в лучшем свете

Если вы полагает, что вашему клиентскому приложению не нужна будет та или иная, используемая зависимость, вы можете внедрить избранные (cherry-picking) функции. Например, чтобы внедрить функцию `fill` из пакета [lodash](https://lodash.com), импортируйте только ее следующим способом:

```js
import fill from 'lodash/fill'
```

Но даже при такой оптимизации код, который будет внедрен в вашу библиотеку, может оказаться большим, потому что та или иная функция может иметь дополнительные зависимости.

Заметьте, что `import { fill } from 'lodash'` или `import _ from 'lodash'` импортируют библиотеку `lodash` полностью.

Наконец, если библиотека `lodash` и так используется в вашем клиентском приложении и вы не хотите, чтобы `lodash` импортировалось и в клиентское приложение, и в вашу библиотеку, вы можете подумать о том, чтобы вынести их в отдельную утилиту и избавить клиентское приложение от необходимости импорта самого `lodash`.

### Генерация типов

Следующие параметры файла [tsconfig.json](tsconfig.json) указывают tsc (typescript compilator) на необходимость создания только объявлений (файлы `.d.ts`), так как `vite build` генерит только JS-файл.

Сгенерированные файл `.d.ts` помещаются в папку `dist/types`.

```json
"compilerOptions": {
  "declaration": true,
  "emitDeclarationOnly": true,
  "declarationDir": "./dist/types"
}
```

Следующая строка в файле [package.json](package.json) указывает на входящий файл с типами для клиентского приложения:

```json
"types": "./dist/types/index.d.ts",
```

> В [vite.config.ts](vite.config.ts) параметр `build.emptyOutDir` установлен как `false`, а `rimraf` используется для удаления папки `dist` перед сборкой. Это сделано для того, чтобы папка  `dist/types`, сгенерированная `tsc`, не удалялась бы при выполнении `vite build`.

### Конфигурация

#### TypeScript

В файле [tsconfig.json](tsconfig.js) установлено нижеследующее значение, рекомендованное Vite (так как используетя esbuild). Однако это приводит к описанной ситуации: https://github.com/vitejs/vite/issues/5814. Чтобы обойти это, можно так же включить `compilerOptions.skipLibCheck`.

```json
"compilerOptions": {
  "isolatedModules": true
}
```

В [tsconfig.json](tsconfig.js), установлено нижеприведенное значение для решения проблемы [Issue #32](https://github.com/wuruoyun/vue-component-lib-starter/issues/32). Решение взято [отсюда](https://github.com/johnsoncodehk/volar/discussions/592).

```json
"compilerOptions": {
  "types": [
    "vite/client"
  ]
}
```

#### Зависимости

В [package.json](package.json) Vue и PrimeVue декларированы как в `peerDependencies`, так и в `devDependencies`. Первое требует, чтобы клиентское приложение обязательно добавило эти зависимости, а второе упрощает установку их вместе с библиотекой простым запуском `npm install`.
